namespace CustomThreading
{
    using System;
    using System.Threading;

    /// <summary>
    /// Represents task generated by <see cref="MyThreadPool"/>
    /// </summary>
    /// <typeparam name="TResult">Task result type</typeparam>
    public class MyTask<TResult> : IMyTask<TResult>
    {
        /// <summary>
        /// Function which is being calculated by <see cref="taskThread"/>
        /// </summary>
        private readonly Func<TResult> supplier;

        /// <summary>
        /// Callback which adds given task to the parent thread pool
        /// </summary>
        private readonly Action<Action<BasePoolThread>> newTaskInstaller;

        /// <summary>
        /// Blocks caller thread until task result is calculated
        /// </summary>
        private readonly ManualResetEvent resultReturnGuard = new ManualResetEvent(false);

        /// <summary>
        /// Main thread which calculates supplier function
        /// </summary>
        private BasePoolThread taskThread;

        /// <summary>
        /// Calculation result
        /// </summary>
        private TResult taskResult;

        /// <summary>
        /// Exception which is possibly occurred during calculation
        /// </summary>
        private Exception occuredException = null;

        /// <summary>
        /// Initializes a new instance of the <see cref="MyTask{TResult}"/> class.
        /// </summary>
        /// <param name="supplier">Supplier function to calculate</param>
        /// <param name="newTaskInstaller">
        /// Callback which adds given task to the parent thread pool
        /// </param>
        /// <param name="enqueueImmediately">
        /// If true then task will be put into pool execution queue immediately
        /// </param>
        public MyTask(
            Func<TResult> supplier,
            Action<Action<BasePoolThread>> newTaskInstaller,
            bool enqueueImmediately = true)
        {
            this.supplier = supplier;
            this.newTaskInstaller = newTaskInstaller;

            if (enqueueImmediately)
            {
                this.EnqueueTask();
            }
        }

        /// <summary>
        /// Is activated when the task has completed its work
        /// and calculated some result
        /// </summary>
        public event EventHandler<TaskResultInfo> TaskCompleted;

        /// <summary>
        /// Gets a value indicating whether task is completed
        /// </summary>
        public bool IsCompleted { get; private set; } = false;

        /// <summary>
        /// Gets task result. Blocks caller thread until result is ready
        /// </summary>
        public TResult Result
        {
            get
            {
                // Waiting while result is being calculated
                this.resultReturnGuard.WaitOne();

                if (this.occuredException == null)
                {
                    return this.taskResult;
                }
                else
                {
                    throw new AggregateException(this.occuredException);
                }
            }
        }

        /// <summary>
        /// Generates new task based on the result of current task
        /// </summary>
        /// <typeparam name="TResultNew">New task result type</typeparam>
        /// <param name="newSupplier">New supplier function</param>
        /// <returns>
        /// Task which executes new supplier function
        /// with the result of current task as a parameter
        /// </returns>
        public IMyTask<TNewResult> ContinueWith<TNewResult>(
            Func<TResult, TNewResult> supplier)
        {
            TNewResult supplierWrapper()
            {
                return supplier(this.Result);
            }

            MyTask<TNewResult> newTask;
            if (this.IsCompleted)
            {
                // Putting task into the queue immediately
                newTask = new MyTask<TNewResult>(
                    supplierWrapper,
                    this.newTaskInstaller,
                    true);
            }
            else
            {
                // New task is waiting for the event from the current
                // thread and then adding itself to the queue
                newTask = new MyTask<TNewResult>(
                    supplierWrapper,
                    this.newTaskInstaller,
                    false);
                this.TaskCompleted += newTask.EnqueueTask;
            }

            return newTask;
        }

        /// <summary>
        /// Enqueue current task to the parent pool execution queue
        /// </summary>
        private void EnqueueTask()
        {
            this.newTaskInstaller(this.AssignThread);
        }

        /// <summary>
        /// Enqueue current task to the parent pool execution queue
        /// </summary>
        /// <param name="sender">Event sender</param>
        /// <param name="info">Information about task execution results</param>
        private void EnqueueTask(object sender, TaskResultInfo info)
        {
            if (info.ThrowedException == null)
            {
                this.EnqueueTask();
            }
        }

        /// <summary>
        /// Callback which assigns given free thread to the current task.
        /// Not thread-safe!
        /// </summary>
        /// <param name="thread">Free thread to assign</param>
        private void AssignThread(BasePoolThread thread)
        {
            TaskResultInfo SupplierWrapper()
            {
                TaskResultInfo executionResult;
                try
                {
                    var result = this.supplier();
                    executionResult = new TaskResultInfo(result);
                }
                catch (Exception e)
                {
                    executionResult = new TaskResultInfo(e);
                }

                return executionResult;
            }

            this.taskThread = thread;
            this.taskThread.CalculationFinished += this.FinalizeTask;
            this.taskThread.AssignTask(SupplierWrapper);
        }

        /// <summary>
        /// Finalizes execution of the task
        /// </summary>
        /// <param name="sender">Event sender</param>
        /// <param name="info">Information about calculation results</param>
        private void FinalizeTask(object sender, TaskResultInfo info)
        {
            if (info.ThrowedException == null)
            {
                this.taskResult = (TResult)info.Result;
                this.occuredException = info.ThrowedException;
            }

            this.taskThread.CalculationFinished -= this.FinalizeTask;
            this.IsCompleted = true;
            this.resultReturnGuard.Set();

            // If there is at least 1 handler
            this.TaskCompleted?.Invoke(this, info);
        }
    }
}